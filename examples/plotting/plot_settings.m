problem_name = 'Van der Pol'; problem_path = '../van_der_pol/';
%problem_name = 'Attitude control'; problem_path = '../satellite/';
%problem_name = "Burgers' PDE"; problem_path = '../burgers/D64/';
%problem_name = 'UAV'; problem_path = '../uav/';

% Tolerance to cutoff "unstable" NNs
fp_tol = 1e-03;

model_info = readtable([problem_path, 'models/model_info.csv']);

% Change training time to minutes
model_info.train_time = model_info.train_time / 60;

% Restrict to models trained with certain number of trajectories
n_traj_train_min = 0;
n_traj_train_max = inf;
optimizer = 'any';
%optimizer = 'L-BFGS-B';
%optimizer = 'AdamOptimizer';

if ~strcmp(optimizer, 'any')
    model_info = model_info(...
        or(...
            strcmp(model_info.optimizer, optimizer),...
            strcmp(model_info.architecture, 'LQR')...
        ), :...
    );
end

model_info = model_info(...
    or(...
            strcmp(model_info.optimizer_opts, '{}'),...
            strcmp(model_info.architecture, 'LQR')...
    ), :...
);

model_info = model_info(...
    or(...
        model_info.n_trajectories_train >= n_traj_train_min,...
        strcmp(model_info.architecture, 'LQR')...
    ), :...
);
model_info = model_info(...
    or(...
        model_info.n_trajectories_train <= n_traj_train_max,...
        strcmp(model_info.architecture, 'LQR')...
    ), :...
);

% Sort results by number of training data
[~,idx] = sort(model_info.n_trajectories_train);
model_info = model_info(idx,:);

% Process monte carlo test results
model_info = get_mc_results(model_info, problem_path, fp_tol);
LQR_info = model_info(strcmp(model_info.architecture, 'LQR'), :);

load('NN_names.mat')

ColorOrder = 1/255*[
    128,205,193;
    53,151,143;
    171,217,233;
    116,173,209;
    69,117,180;
    49,54,149;
    253,174,97;
    244,109,67;
    215,48,39;
    165,0,38;
];

markers = ['*';'v';'s';'^';'+';'p';'o';'d';'x';'h';'>';'<'];

name_groups = [
    struct(...
        "names", ["ValueNN", "GradientNN", "ControlNN"],...
        "overwrite_legend_name", false,...
        "marker", '*', "color", [166,206,227]/255 ...
    );
    struct(...
        "names", "ValueQRnet",...
        "overwrite_legend_name", false,...
        "marker", "s", "color", [31,120,180]/255 ...
    );
    struct(...
        "names", ["GradientQRnet", "ControlQRnet"],...
        "overwrite_legend_name", false,...
        "marker", 'd', "color", [178,223,138]/255 ...
    );
    struct(...
        "names", ["GradientJacQRnet", "ControlJacQRnet", "GradientMatQRnet", "ControlMatQRnet"],...
        "overwrite_legend_name", "grad. \& mat. QRnet",...
        "marker", 'x', "color", [51,160,44]/255 ...
    );
];

% Comment this line out to plot results in groups listed above
name_groups = [];

if isempty(name_groups)
    idx = 1:10;

    NN_names = NN_names(idx);
    legend_names = legend_names(idx);
    ColorOrder = ColorOrder(idx,:);
    markers = markers(idx);

else
    for g = 1:length(name_groups)
        for architecture = name_groups(g).names
            if contains(architecture, NN_names)
                % Construct the legend name for the group
                legend_name = legend_names(strcmp(architecture, NN_names));
                if isfield(name_groups(g), "legend_name")
                    name_groups(g).legend_name = join([name_groups(g).legend_name; legend_name], ", ");
                else
                    name_groups(g).legend_name = legend_name;
                end
    
                % Rename table entries 
                idx = strcmp(model_info.architecture, architecture);
    
                model_info(idx, 'architecture') = table(repmat({['group', num2str(g)]}, sum(idx), 1));
            end
        end
    end

    NN_names = string;
    legend_names = string;
    ColorOrder = [0,0,0];
    markers = string;

    for g = 1:length(name_groups)
        NN_names(g,1) = ['group', num2str(g)];
        if isstring(name_groups(g).overwrite_legend_name)
            legend_names(g,1) = name_groups(g).overwrite_legend_name;
        else
            legend_names(g,1) = name_groups(g).legend_name;
        end
        ColorOrder(g,:) = name_groups(g).color;
        markers(g,1) = name_groups(g).marker;
    end
end

y_settings = struct;
y_settings.frac_stable = struct(...
    "label", "fraction $\Vert \mathbf x (t_f) - \mathbf x_f \Vert < \delta$",...
    "title", "proportion stabilized",...
    "yline_LQR", true, ...
    "yline", 1, ...
    "ylim", [0,1.1]...
);
y_settings.median_final_dist = struct(...
    "label", "median $\Vert \mathbf x (t_f) - \mathbf x_f \Vert$",...
    "title", "semi-global stability",...
    "scale", "log",...
    "yline", fp_tol...
);
y_settings.max_final_dist = struct(...
    "label", "max $\Vert \mathbf x (t_f) - \mathbf x_f \Vert$",...
    "title", "semi-global stability",...
    "scale", "log",...
    "yline", fp_tol...
);
y_settings.max_eig_real = struct(...
    "label", "most positive eigenvalue",...
    "title", "local stability",...
    "yline", 0.0,...
    "yline_LQR", true ...
);
y_settings.median_subopt = struct(...
    "label", "median $\%$suboptimality",...
    "title", "optimality",...
    "scale", "log",...
    "yline_LQR", true ...
);
y_settings.max_subopt = struct(...
    "label", "max $\%$suboptimality",...
    "title", "optimality",...
    "scale", "log",...
    "yline_LQR", true ...
);
y_settings.median_final_time = struct(...
    "label", "median $t_f / t_f^*$",...
    "title", "settling time",...
    "yline_LQR", true,...
    "scale", "log"...
);
y_settings.max_final_time = struct(...
    "label", "max $t_f / t_f^*$",...
    "title", "settling time",...
    "yline_LQR", true,...
    "scale", "log"...
);
y_settings.train_time = struct(...
    "label", "minutes",...
    "title", "training time" ...
);
y_settings.U_RML2_test = struct(...
    "title", "control approximation",...
    "label", "control RM$\ell^2$",...
    "scale", "log",...
    "ylim", [1e-03,1],...
    "yline_LQR", true...
);
y_settings.U_ML2_test = struct(...
    "title", "control approximation",...
    "label", "control mean $\ell^2$",...
    "scale", "log",...
    "ylim", [1e-03,1],...
    "yline_LQR", true ...
);
y_settings.U_maxL2_test = struct(...
    "title", "control approximation",...
    "label", "control max $\ell^2$",...
    "ylim", [0,1],...
    "yline_LQR", true ...
);